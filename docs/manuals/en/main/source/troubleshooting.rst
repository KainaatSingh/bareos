Debug Messages
==============

The Bareos programs contain a lot of debug messages. Normally, these are
not printed. See the :ref:`setdebug bcommandSetdebug`
chapter about how to enable them.

Client Access Problems
======================


.. index:: 
   triple: General; Problem; Cannot Access a Client There are
several reasons why a  |bareosDir| could not contact a client
on a different machine. They are:

-  Check if the client file daemon is really running.

-  The Client address or port is incorrect or not resolved by DNS. See
   if you can ping the client machine using the same address as in the
   Client record.

-  You have a firewall, and it is blocking traffic on port 9102 between
   the Director’s machine and the Client’s machine (or on port 9103
   between the Client and the Storage daemon machines).

-  If your system is using Tcpwrapper (*hosts.allow*
   or *hosts.deny* file), verify that is permitting
   access.

-  Your password or names are not correct in both the Director and the
   Client machine. Try configuring everything identical to how you run
   the client on the same machine as the Director, but just change the
   address. If that works, make the other changes one step at a time
   until it works.

Some of the DNS and Firewall problems can be circumvented by configuring
clients using :ref:`sec:ClientInitiatedConnection` or as
:ref:`PassiveClient`.

Difficulties Connecting from the FD to the SD
---------------------------------------------


.. index:: 
   triple: General; Problem; Connecting from the FD to the SD

If you are having difficulties getting one or more of your File daemons
to connect to the Storage daemon, it is most likely because you have not
used a fully qualified domain name on the
:raw-latex:`\linkResourceDirective{Dir}{Storage}{Address}` directive.
That is the resolver on the File daemon’s machine (not on the
Director’s) must be able to resolve the name you supply into an IP
address. An example of an address that is guaranteed not to work:
**localhost**. An example that may work:
**bareos-sd1**. An example that is more likely to work:
**bareos-sd1.example.com**.

You can verify how a  |bareosFd| resolves a DNS name by the
following command:

.. raw:: latex

   \begin{bconsole}{Test DNS resolution of the \bareosFd \name{bareos-fd}}
   *<input>resolve client=bareos-fd NONEXISTINGHOSTNAME</input>
   Connecting to Client bareos-fd at bareos:9102
   bareos-fd: Failed to resolve NONEXISTINGHOSTNAME
   *<input>resolve client=bareos-fd bareos-sd1.example.com</input>
   Connecting to Client bareos-fd at bareos:9102
   bareos-fd resolves bareos-sd1.example.com to host[ipv4;192.168.0.1]
   \end{bconsole}

If your address is correct, then make sure that no other program is
using the port 9103 on the Storage daemon’s machine. The Bacula project
has reserved these port numbers by IANA, therefore they should only be
used by Bacula and its replacements like Bareos. However, apparently
some HP printers do use these port numbers. A
:command:`netstat -lntp` on the  |bareosSd| ’s
machine can determine who is listening on the 9103 port (used for FD to
SD communications in Bareos).

Authorization Errors
--------------------


.. index:: 
   triple: General; Problem; Authorization Errors
.. index:: General; Concurrent Jobs 
.. _AuthorizationErrors:

For security reasons, Bareos requires that both the File daemon and the
Storage daemon know the name of the Director as well as its password. As
a consequence, if you change the Director’s name or password, you must
make the corresponding change in the Storage daemon’s and in the File
daemon’s configuration files.

During the authorization process, the Storage daemon and File daemon
also require that the Director authenticates itself, so both ends
require the other to have the correct name and password.

If you have edited the configuration files and modified any name or any
password, and you are getting authentication errors, then your best bet
is to go back to the original configuration files generated by the
Bareos installation process. Make only the absolutely necessary
modifications to these files – e.g. add the correct email address. Then
follow the instructions in the
:ref:`Running Bareos TutorialChapter` chapter of this
manual. You will run a backup to disk and a restore. Only when that
works, should you begin customization of the configuration files.

Some users report that authentication fails if there is not a proper
reverse DNS lookup entry for the machine. This seems to be a requirement
of gethostbyname(), which is what Bareos uses to translate names into IP
addresses. If you cannot add a reverse DNS entry, or you don’t know how
to do so, you can avoid the problem by specifying an IP address rather
than a machine name in the appropriate Bareos configuration file.

Here is a picture that indicates what names/passwords in which
files/Resources must match up:

|image|

In the left column, you will find the Director, Storage, and Client
resources, with their names and passwords – these are all in the
 |bareosDir| configuration. The right column is where the
corresponding values should be found in the Console, Storage daemon
(SD), and File daemon (FD) configuration files.

Another thing to check is to ensure that the Bareos component you are
trying to access has
:raw-latex:`\configdirective{Maximum Concurrent Jobs}` set large enough
to handle each of the Jobs and the Console that want to connect
simultaneously. Once the maximum connections has been reached, each
Bareos component will reject all new connections.

Concurrent Jobs
===============


.. index:: 
   triple: General; Job; Concurrent Jobs
.. index:: General; Running Concurrent Jobs 
.. index:: General; Concurrent Jobs 

Bareos can run multiple concurrent jobs. Using the
:raw-latex:`\configdirective{Maximum Concurrent Jobs}` directives, you
can configure how many and which jobs can be run simultaneously:

 |bareosDir| 
    | 

    -  :raw-latex:`\linkResourceDirective{Dir}{Director}{Maximum Concurrent Jobs}`

    -  :raw-latex:`\linkResourceDirective{Dir}{Client}{Maximum Concurrent Jobs}`

    -  :raw-latex:`\linkResourceDirective{Dir}{Job}{Maximum Concurrent Jobs}`

    -  :raw-latex:`\linkResourceDirective{Dir}{Storage}{Maximum Concurrent Jobs}`

 |bareosSd| 
    | 

    -  :raw-latex:`\linkResourceDirective{Sd}{Storage}{Maximum Concurrent Jobs}`

    -  :raw-latex:`\linkResourceDirective{Sd}{Device}{Maximum Concurrent Jobs}`

 |bareosFd| 
    | 

    -  :raw-latex:`\linkResourceDirective{Fd}{Client}{Maximum Concurrent Jobs}`

For example, if you want two different jobs to run simultaneously
backing up the same Client to the same Storage device, they will run
concurrently only if you have set
:raw-latex:`\configdirective{Maximum Concurrent Jobs}` greater than one
in the :raw-latex:`\configresource{Director}` resource, the
:raw-latex:`\configresource{Client}` resource, and the
:raw-latex:`\configresource{Storage}` resource in
 |bareosDir| configuration.

.. _sec:Interleaving: When running concurrent jobs
without :ref:`sec:DataSpooling`, the volume format
becomes more complicated, consequently, restores may take longer if
Bareos must sort through interleaved volume blocks from multiple
simultaneous jobs. This can be avoided by having each simultaneous job
write to a different volume or by using data spooling We recommend that
you read the :ref:`sec:DataSpooling` of this manual
first, then test your multiple concurrent backup including restore
testing before you put it into production.

When using random access media as backup space (e.g. disk), you should
also read the chapter about :ref:`ConcurrentDiskJobs`.

Below is a super stripped down *bareos-dir.conf* file
showing you the four places where the the file must be modified to allow
the same job :raw-latex:`\resourcename{Dir}{Job}{NightlySave}` to run up
to four times concurrently. The change to the Job resource is not
necessary if you want different Jobs to run at the same time, which is
the normal case.

.. raw:: latex

   \begin{bconfig}{Concurrent Jobs Example}
   #
   # Bareos Director Configuration file -- bareos-dir.conf
   #
   Director {
     Name = rufus-dir
     Maximum Concurrent Jobs = 4
     ...
   }
   Job {
     Name = "NightlySave"
     Maximum Concurrent Jobs = 4
     Client = rufus-fd
     Storage = File
     ...
   }
   Client {
     Name = rufus-fd
     Maximum Concurrent Jobs = 4
     ...
   }
   Storage {
     Name = File
     Maximum Concurrent Jobs = 4
     ...
   }
   \end{bconfig}

Tape Labels: ANSI or IBM
========================


.. index:: 
   triple: General; Label; Tape Labels

.. index:: 
   triple: General; Tape!Label; ANSI

.. index:: 
   triple: General; Tape!Label; IBM

By default, Bareos uses its own tape label (see
:ref:`backward-compability-tape-format` and
:raw-latex:`\linkResourceDirective{Dir}{Pool}{Label Type}`). However,
Bareos also supports reading and write ANSI and IBM tape labels.

Reading
-------

Reading ANSI/IBM labels is important, if some of your tapes are used by
other programs that also support ANSI/IBM labels. For example, LTFS
tapes 
.. index:: 
   triple: General; Tape; LTFS are indicated by an ANSI
label.

If your are running Bareos in such an environment, you must set
:raw-latex:`\linkResourceDirective{Sd}{Device}{Check Labels}` to yes,
otherwise Bareos will not recognize that these tapes are already in use.

Writing
-------

To configure Bareos to also write ANSI/IBM tape labels, use
:raw-latex:`\linkResourceDirective{Dir}{Pool}{Label Type}` or
:raw-latex:`\linkResourceDirective{Sd}{Device}{Label Type}`. With the
proper configuration, you can force Bareos to require ANSI or IBM
labels.

Even though Bareos will recognize and write ANSI and IBM labels, it
always writes its own tape labels as well.

If you have labeled your volumes outside of Bareos, then the ANSI/IBM
label will be recognized by Bareos only if you have created the HDR1
label with **BAREOS.DATA** in the filename field (starting with
character 5). If Bareos writes the labels, it will use this information
to recognize the tape as a Bareos tape. This allows ANSI/IBM labeled
tapes to be used at sites with multiple machines and multiple backup
programs.

Tape Drive
==========


.. index:: 
   triple: General; Problem; Tape

This chapter is concerned with testing and configuring your tape drive
to make sure that it will work properly with Bareos using the **btape**
program.

Get Your Tape Drive Working
---------------------------

In general, you should follow the following steps to get your tape drive
to work with Bareos. Start with a tape mounted in your drive. If you
have an autochanger, load a tape into the drive. We use **/dev/nst0** as
the tape drive name, you will need to adapt it according to your system.

Do not proceed to the next item until you have succeeded with the
previous one.

#. Make sure that Bareos (the Storage daemon) is not running or that you
   have **unmount**\ ed the drive you will use for testing.

#. Use tar to write to, then read from your drive:

   

   ::

          mt -f /dev/nst0 rewind
          tar cvf /dev/nst0 .
          mt -f /dev/nst0 rewind
          tar tvf /dev/nst0

   

#. Make sure you have a valid and correct Device resource corresponding
   to your drive. For Linux users, generally, the default one works. For
   FreeBSD users, there are two possible Device configurations (see
   below). For other drives and/or OSes, you will need to first ensure
   that your system tape modes are properly setup (see below), then
   possibly modify you Device resource depending on the output from the
   btape program (next item). When doing this, you should consult the
   :raw-latex:`\ilink{Storage Daemon
      Configuration}{StoredConfChapter}` of this manual.

#. If you are using a Fibre Channel to connect your tape drive to
   Bareos, please be sure to disable any caching in the NSR (network
   storage router, which is a Fibre Channel to SCSI converter).

#. Run the btape **test** command:

   

   ::

          btape /dev/nst0
          test

   

   It isn’t necessary to run the autochanger part of the test at this
   time, but do not go past this point until the basic test succeeds. If
   you do have an autochanger, please be sure to read the
   :raw-latex:`\ilink{Autochanger
      chapter}{AutochangersChapter}` of this manual.

#. Run the btape **fill** command, preferably with two volumes. This can
   take a long time. If you have an autochanger and it is configured,
   Bareos will automatically use it. If you do not have it configured,
   you can manually issue the appropriate **mtx** command, or press the
   autochanger buttons to change the tape when requested to do so.

#. Run Bareos, and backup a reasonably small directory, say 60
   Megabytes. Do three successive backups of this directory.

#. Stop Bareos, then restart it. Do another full backup of the same
   directory. Then stop and restart Bareos.

#. Do a restore of the directory backed up, by entering the following
   restore command, being careful to restore it to an alternate
   location:

   

   ::

          restore select all done
          yes

   

   Do a **diff** on the restored directory to ensure it is identical to
   the original directory. If you are going to backup multiple different
   systems (Linux, Windows, Mac, Solaris, FreeBSD, ...), be sure you
   test the restore on each system type.

#. If you have an autochanger, you should now go back to the btape
   program and run the autochanger test:

   

   ::

            btape /dev/nst0
            auto

   

   Adjust your autochanger as necessary to ensure that it works
   correctly. See the
   :ref:`Autochanger chapter AutochangerTesting` of this
   manual for a complete discussion of testing your autochanger.

:raw-latex:`\hide{
If you have reached this point, you stand a good chance of having everything
work. If you get into trouble at any point, {\bf carefully} read the
documentation given below.

\subsection{btape}
\label{btape1}
\index[general]{btape}

This program permits a number of elementary tape operations via a tty command
interface. The {\bf test} command, described below, can be very useful for
testing tape drive compatibility problems. Aside from initial testing of tape
drive compatibility with {\bf Bareos}, {\bf btape} will be mostly used by
developers writing new tape drivers.

{\bf btape} can be dangerous to use with existing {\bf Bareos} tapes because
it will relabel a tape or write on the tape if so requested regardless of
whether or not the tape contains valuable data, so please be careful and use
it only on blank tapes.

To work properly, \command{btape} needs to read the Storage daemon's configuration.

The physical device name or the Device resource name must be specified on the
command line, and this same device name must be present in the Storage
daemon's configuration file read by \command{btape}

\footnotesize
\begin{verbatim}
Usage: btape [options] device_name
       -b <file>   specify bootstrap file
       -c <file>   set configuration file to file
       -d <nn>     set debug level to nn
       -p          proceed inspite of I/O errors
       -s          turn off signals
       -v          be verbose
       -?          print this message.
\end{verbatim}
\normalsize




\label{problems1}
\subsection{Tips for Resolving Problems}
\index[general]{Problems!Tips for Resolving}
\index[general]{Tips for Resolving Problems}

\label{CannotRestore}
\subsubsection{Bareos Saves But Cannot Restore Files}
\index[general]{Files!Bareos Saves But Cannot Restore}
\index[general]{Bareos Saves But Cannot Restore Files}

If you are getting error messages such as:

\footnotesize
\begin{verbatim}
Volume data error at 0:1! Wanted block-id: "BB02", got "". Buffer discarded
\end{verbatim}
\normalsize

It is very likely that Bareos has tried to do block positioning and ended up
at an invalid block. This can happen if your tape drive is in fixed block mode
while Bareos's default is variable blocks. Note that in such cases, Bareos is
perfectly able to write to your Volumes (tapes), but cannot position to read
them.

There are two possible solutions.

\begin{enumerate}
\item The first and  best is to always ensure that your drive is in  variable
   block mode. Note, it can switch back to  fixed block mode on a reboot or if
   another program  uses the drive. So on such systems you  need to modify the
   Bareos startup files  to explicitly set:

\footnotesize
\begin{verbatim}
mt -f /dev/nst0 defblksize 0
\end{verbatim}
\normalsize

or whatever is appropriate on your system. Note, if you are running a Linux
system, and the above command does not work, it is most likely because you
have not loaded the appropriate {\bf mt} package, which is often called
{\bf mt\_st}, but may differ according to your distribution.

\item The second possibility, especially, if Bareos wrote  while the drive was
   in fixed block mode, is to turn  off block positioning in Bareos. This is done
   by  adding:

\footnotesize
\begin{verbatim}
Block Positioning = no
\end{verbatim}
\normalsize

to the Device resource. This is not the recommended  procedure because it can
enormously slow down  recovery of files, but it may help where all else
fails. This directive is available in version 1.35.5  or later (and not yet
tested).
\end{enumerate}

If you are getting error messages such as:
\footnotesize
\begin{verbatim}
Volume data error at 0:0!
Block checksum mismatch in block=0 len=32625 calc=345678 blk=123456
\end{verbatim}
\normalsize

You are getting tape read errors, and this is most likely due to
one of the following things:
\begin{enumerate}
\item An old or bad tape.
\item A dirty drive that needs cleaning (particularly for DDS drives).
\item A loose SCSI cable.
\item Old firmware in your drive. Make sure you have the latest firmware
      loaded.
\item Computer memory errors.
\item Over-clocking your CPU.
\item A bad SCSI card.
\end{enumerate}


\label{opendevice}
\subsubsection{Bareos Cannot Open the Device}
\index[general]{Device!Bareos Cannot Open the}
\index[general]{Bareos Cannot Open the Device}

If you get an error message such as:

\footnotesize
\begin{verbatim}
dev open failed: dev.c:265 stored: unable to open
device /dev/nst0:> ERR=No such device or address
\end{verbatim}
\normalsize

the first time you run a job, it is most likely due to the fact that you
specified the incorrect device name on your {\bf Archive Device}.

If Bareos works fine with your drive, then all off a sudden you get error
messages similar to the one shown above, it is quite possible that your driver
module is being removed because the kernel deems it idle. This is done via
{\bf crontab} with the use of {\bf rmmod -a}. To fix the problem, you can
remove this entry from {\bf crontab}, or you can manually {\bf modprob} your
driver module (or add it to the local startup script). Thanks to Alan Brown
for this tip.
\label{IncorrectFiles}

\subsubsection{Incorrect File Number}
\index[general]{Number!Incorrect File}
\index[general]{Incorrect File Number}

When Bareos moves to the end of the medium, it normally uses the {\bf
ioctl(MTEOM)} function. Then Bareos uses the {\bf ioctl(MTIOCGET)} function to
retrieve the current file position from the {\bf mt\_fileno} field. Some SCSI
tape drivers will use a fast means of seeking to the end of the medium and in
doing so, they will not know the current file position and hence return a {\bf
-1}. As a consequence, if you get {\bf "This is NOT correct!"} in the
positioning tests, this may be the cause. You must correct this condition in
order for Bareos to work.

There are two possible solutions to the above problem of incorrect file
number:

\begin{itemize}
\item Figure out how to configure your SCSI driver to  keep track of the file
   position during the MTEOM  request. This is the preferred solution.
\item Modify the {\bf Device} resource of your {\bf bareos-sd.conf} file  to
   include:

\footnotesize
\begin{verbatim}
Hardware End of File = no
\end{verbatim}
\normalsize

This will cause Bareos to use the MTFSF request to  seek to the end of the
medium, and Bareos will keep  track of the file number itself.
\end{itemize}

\label{IncorrectBlocks}
\subsubsection{Incorrect Number of Blocks or Positioning Errors}
\index[general]{Testing!Incorrect Number of Blocks or Positioning Errors}
\index[general]{Incorrect Number of Blocks or Positioning Errors}

{\bf Bareos's} preferred method of working with tape drives (sequential
devices) is to run in variable block mode, and this is what is set by default.
You should first ensure that your tape drive is set for variable block mode
(see below).

If your tape drive is in fixed block mode and you have told Bareos to use
different fixed block sizes or variable block sizes (default), you will get
errors when Bareos attempts to forward space to the correct block (the kernel
driver's idea of tape blocks will not correspond to Bareos's).

All modern tape drives support variable tape blocks, but some older drives (in
particular the QIC drives) as well as the ATAPI ide-scsi driver run only in
fixed block mode. The Travan tape drives also apparently must run in fixed
block mode (to be confirmed).

Even in variable block mode, with the exception of the first record on the
second or subsequent volume of a multi-volume backup, Bareos will write blocks
of a fixed size. However, in reading a tape, Bareos will assume that for each
read request, exactly one block from the tape will be transferred. This the
most common way that tape drives work and is well supported by {\bf Bareos}.

Drives that run in fixed block mode can cause serious problems for Bareos if
the drive's block size does not correspond exactly to {\bf Bareos's} block
size. In fixed block size mode, drivers may transmit a partial block or
multiple blocks for a single read request. From {\bf Bareos's} point of view,
this destroys the concept of tape blocks. It is much better to run in variable
block mode, and almost all modern drives run in
variable block mode. In order for Bareos to run in fixed block mode, you must
include the following records in the Storage daemon's Device resource
definition:

\footnotesize
\begin{verbatim}
Minimum Block Size = nnn
Maximum Block Size = nnn
\end{verbatim}
\normalsize

where {\bf nnn} must be the same for both records and must be identical to the
driver's fixed block size.

We recommend that you avoid this configuration if at all possible by using
variable block sizes.

If you must run with fixed size blocks, make sure they are not 512 bytes. This
is too small and the overhead that Bareos has with each record will become
excessive. If at all possible set any fixed block size to something like
64,512 bytes or possibly 32,768 if 64,512 is too large for your drive. See
below for the details on checking and setting the default drive block size.

To recover files from tapes written in fixed block mode, see below.

\label{TapeModes}
\subsubsection{Ensuring that the Tape Modes Are Properly Set -- {\bf Linux
Only}}
\index[general]{Ensuring that the Tape Modes Are Properly Set -- Linux Only}

If you have a modern SCSI tape drive and you are having problems with the {\bf
test} command as noted above, it may be that some program has set one or more
of your SCSI driver's options to non-default values. For example, if your
driver is set to work in SysV manner, Bareos will not work correctly because
it expects BSD behavior. To reset your tape drive to the default values, you
can try the following, but {\bf ONLY} if you have a SCSI tape drive on a {\bf
Linux} system:

\footnotesize
\begin{verbatim}
become super user
mt -f /dev/nst0 rewind
mt -f /dev/nst0 stoptions buffer-writes async-writes read-ahead
\end{verbatim}
\normalsize

The above commands will clear all options and then set those specified. None
of the specified options are required by Bareos, but a number of other options
such as SysV behavior must not be set. Bareos does not support SysV tape
behavior. On systems other than Linux, you will need to consult your {\bf mt}
man pages or documentation to figure out how to do the same thing. This should
not really be necessary though -- for example, on both Linux and Solaris
systems, the default tape driver options are compatible with Bareos.
On Solaris systems, you must take care to specify the correct device
name on the {\bf Archive device} directive. See above for more details.

You may also want to ensure that no prior program has set the default block
size, as happened to one user, by explicitly turning it off with:

\footnotesize
\begin{verbatim}
mt -f /dev/nst0 defblksize 0
\end{verbatim}
\normalsize

If you are running a Linux
system, and the above command does not work, it is most likely because you
have not loaded the appropriate {\bf mt} package, which is often called
{\bf mt\_st}, but may differ according to your distribution.

If you would like to know what options you have set before making any of the
changes noted above, you can now view them on Linux systems, thanks to a tip
provided by Willem Riede. Do the following:

\footnotesize
\begin{verbatim}
become super user
mt -f /dev/nst0 stsetoptions 0
grep st0 /var/log/messages
\end{verbatim}
\normalsize

and you will get output that looks something like the following:

\footnotesize
\begin{verbatim}
kernel: st0: Mode 0 options: buffer writes: 1, async writes: 1, read ahead: 1
kernel: st0:    can bsr: 0, two FMs: 0, fast mteom: 0, auto lock: 0,
kernel: st0:    defs for wr: 0, no block limits: 0, partitions: 0, s2 log: 0
kernel: st0:    sysv: 0 nowait: 0
\end{verbatim}
\normalsize

Note, I have chopped off the beginning of the line with the date and machine
name for presentation purposes.

Some people find that the above settings only last until the next reboot, so
please check this otherwise you may have unexpected problems.

Beginning with Bareos version 1.35.8, if Bareos detects that you are running
in variable block mode, it will attempt to set your drive appropriately. All
OSes permit setting variable block mode, but some OSes do not permit setting
the other modes that Bareos needs to function properly.


\subsubsection{Tape Modes on FreeBSD}
\label{FreeBSDTapes}
\index[general]{FreeBSD!Tape Modes on}
\index[general]{Tape Modes on FreeBSD}

On most FreeBSD systems such as 4.9 and most tape drives, Bareos should run
with:

\footnotesize
\begin{verbatim}
mt  -f  /dev/nsa0  seteotmodel  2
mt  -f  /dev/nsa0  blocksize   0
mt  -f  /dev/nsa0  comp  enable
\end{verbatim}
\normalsize

You might want to put those commands in a startup script to make sure your
tape driver is properly initialized before running Bareos, because
depending on your system configuration, these modes may be reset if a
program other than Bareos uses the drive or when your system is rebooted.

Then according to what the {\bf btape test} command returns, you will probably
need to set the following (see below for an alternative):

\footnotesize
\begin{verbatim}
  Hardware End of Medium = no
  BSF at EOM = yes
  Backward Space Record = no
  Backward Space File = no
  Fast Forward Space File = no
  TWO EOF = yes
\end{verbatim}
\normalsize

Then be sure to run some append tests with Bareos where you start and stop
Bareos between appending to the tape, or use {\bf btape} version 1.35.1 or
greater, which includes simulation of stopping/restarting Bareos.

Please see the file {\bf platforms/freebsd/pthreads-fix.txt} in the main
Bareos directory concerning {\bf important} information concerning
compatibility of Bareos and your system. A much more optimal Device
configuration is shown below, but does not work with all tape drives. Please
test carefully before putting either into production.

Note, for FreeBSD 4.10-RELEASE, using a Sony TSL11000 L100 DDS4 with an
autochanger set to variable block size and DCLZ compression, Brian McDonald
reports that to get Bareos to append correctly between Bareos executions,
the correct values to use are:

\footnotesize
\begin{verbatim}
mt  -f  /dev/nsa0  seteotmodel  1
mt  -f  /dev/nsa0  blocksize  0
mt  -f /dev/nsa0  comp  enable
\end{verbatim}
\normalsize

and

\footnotesize
\begin{verbatim}
  Hardware End of Medium = no
  BSF at EOM = no
  Backward Space Record = no
  Backward Space File = no
  Fast Forward Space File = yes
  TWO EOF = no
\end{verbatim}
\normalsize

This has been confirmed by several other people using different hardware. This
configuration is the preferred one because it uses one EOF and no backspacing
at the end of the tape, which works much more efficiently and reliably with
modern tape drives.

Finally, here is a Device configuration that Danny Butroyd reports to work
correctly with the Overland Powerloader tape library using LT0-2 and
FreeBSD 5.4-Stable:

\footnotesize
\begin{verbatim}
# Overland Powerloader LT02 - 17 slots single drive
Device {
  Name = Powerloader
  Media Type = LT0-2
  Archive Device = /dev/nsa0
  AutomaticMount = yes;
  AlwaysOpen = yes;
  RemovableMedia = yes;
  RandomAccess = no;
  Changer Command = "/usr/local/sbin/mtx-changer %c %o %S %a %d"
  Changer Device = /dev/pass2
  AutoChanger = yes
  Alert Command = "sh -c 'tapeinfo -f %c |grep TapeAlert|cat'"

  # FreeBSD Specific Settings
  Offline On Unmount = no
  Hardware End of Medium = no
  BSF at EOM = yes
  Backward Space Record = no
  Fast Forward Space File = no
  TWO EOF = yes
}

The following Device resource works fine with Dell PowerVault 110T and
120T devices on both FreeBSD 5.3 and on NetBSD 3.0.  It also works
with Sony AIT-2 drives on FreeBSD.
\footnotesize
\begin{verbatim}
Device {
  ...
  # FreeBSD/NetBSD Specific Settings
  Hardware End of Medium = no
  BSF at EOM = yes
  Backward Space Record = no
  Fast Forward Space File = yes
  TWO EOF = yes
}
\end{verbatim}
\normalsize

On FreeBSD version 6.0, it is reported that you can even set
Backward Space Record = yes.



\subsubsection{Finding your Tape Drives and Autochangers on FreeBSD}
\index[general]{FreeBSD!Finding Tape Drives and Autochangers}
\index[general]{Finding Tape Drives and Autochangers on FreeBSD}

On FreeBSD, you can do a {\bf camcontrol devlist} as root to determine what
drives and autochangers you have. For example,

\footnotesize
\begin{verbatim}
undef# camcontrol devlist
    at scbus0 target 2 lun 0 (pass0,sa0)
    at scbus0 target 4 lun 0 (pass1,sa1)
    at scbus0 target 4 lun 1 (pass2)
\end{verbatim}
\normalsize

from the above, you can determine that there is a tape drive on {\bf /dev/sa0}
and another on {\bf /dev/sa1} in addition since there is a second line for the
drive on {\bf /dev/sa1}, you know can assume that it is the control device for
the autochanger (i.e. {\bf /dev/pass2}). It is also the control device name to
use when invoking the tapeinfo program. E.g.

\footnotesize
\begin{verbatim}
tapeinfo -f /dev/pass2
\end{verbatim}
\normalsize


\label{fill}
\subsubsection{Using btape to Simulate Filling a Tape}
\index[general]{Using btape to Simulate Filling a Tape}
\index[general]{Tape!Using btape to Simulate Filling}

Because there are often problems with certain tape drives or systems when end
of tape conditions occur, {\bf btape} has a special command {\bf fill} that
causes it to write random data to a tape until the tape fills. It then writes
at least one more Bareos block to a second tape. Finally, it reads back both
tapes to ensure that the data has been written in a way that Bareos can
recover it. Note, there is also a single tape option as noted below, which you
should use rather than the two tape test. See below for more details.

This can be an extremely time consuming process (here it is about 6 hours) to
fill a full tape. Note, that btape writes random data to the tape when it is
filling it. This has two consequences: 1. it takes a bit longer to generate
the data, especially on slow CPUs. 2. the total amount of data is
approximately the real physical capacity of your tape, regardless of whether
or not the tape drive compression is on or off. This is because random data
does not compress very much.

To begin this test, you enter the {\bf fill} command and follow the
instructions. There are two options: the simple single tape option and the
multiple tape option. Please use only the simple single tape option because
the multiple tape option still doesn't work totally correctly. If the single
tape option does not succeed, you should correct the problem before using
Bareos.
\label{RecoveringFiles}

\subsection{Recovering Files Written With Fixed Block Sizes}
\index[general]{Recovering Files Written With Fixed Block Sizes}

If you have been previously running your tape drive in fixed block mode
(default 512) and Bareos with variable blocks (default), then in version
1.32f-x and 1.34 and above, Bareos will fail to recover files because it does
block spacing, and because the block sizes don't agree between your tape drive
and Bareos it will not work.

The long term solution is to run your drive in variable block mode as
described above. However, if you have written tapes using fixed block sizes,
this can be a bit of a pain. The solution to the problem is: while you are
doing a restore command using a tape written in fixed block size, ensure that
your drive is set to the fixed block size used while the tape was written.
Then when doing the {\bf restore} command in the Console program, do not
answer the prompt {\bf yes/mod/no}. Instead, edit the bootstrap file (the
location is listed in the prompt) using any ASCII editor. Remove all {\bf
VolBlock} lines in the file. When the file is re-written, answer the question,
and Bareos will run without using block positioning, and it should recover
your files.

\label{BlockModes}
\subsection{Tape Blocking Modes}
\index[general]{Modes!Tape Blocking}
\index[general]{Tape Blocking Modes}

SCSI tapes may either be written in {\bf variable} or {\bf fixed} block sizes.
Newer drives support both modes, but some drives such as the QIC devices
always use fixed block sizes. Bareos attempts to fill and write complete
blocks (default 65K), so that in normal mode (variable block size), Bareos
will always write blocks of the same size except the last block of a Job. If
Bareos is configured to write fixed block sizes, it will pad the last block of
the Job to the correct size. Bareos expects variable tape block size drives to
behave as follows: Each write to the drive results in a single record being
written to the tape. Each read returns a single record. If you request less
bytes than are in the record, only those number of bytes will be returned, but
the entire logical record will have been read (the next read will retrieve the
next record). Thus data from a single write is always returned in a single
read, and sequentially written records are returned by sequential reads.

Bareos expects fixed block size tape drives to behave as follows: If a write
length is greater than the physical block size of the drive, the write will be
written as two blocks each of the fixed physical size. This single write may
become multiple physical records on the tape. (This is not a good situation).
According to the documentation, one may never write an amount of data that is
not the exact multiple of the blocksize (it is not specified if an error
occurs or if the the last record is padded). When reading, it is my
understanding that each read request reads one physical record from the tape.
Due to the complications of fixed block size tape drives, you should avoid
them if possible with Bareos, or you must be ABSOLUTELY certain that you use
fixed block sizes within Bareos that correspond to the physical block size of
the tape drive. This will ensure that Bareos has a one to one correspondence
between what it writes and the physical record on the tape.

Please note that Bareos will not function correctly if it writes a block and
that block is split into two or more physical records on the tape. Bareos
assumes that each write causes a single record to be written, and that it can
sequentially recover each of the blocks it has written by using the same
number of sequential reads as it had written.

\subsection{Details of Tape Modes}
\index[general]{Modes!Details}
\index[general]{Details of Tape Modes}
Rudolf Cejka has provided the following information concerning
certain tape modes and MTEOM.

\begin{description}
\item[Tape level]
  It is always possible to position filemarks or blocks, whereas
  positioning to the end-of-data is only optional feature, however it is
  implemented very often.  SCSI specification also talks about optional
  sequential filemarks, setmarks and sequential setmarks, but these are not
  implemented so often.  Modern tape drives keep track of file positions in
  built-in chip (AIT, LTO) or at the beginning of the tape (SDLT), so there
  is not any speed difference, if end-of-data or filemarks is used (I have
  heard, that LTO-1 from all 3 manufacturers do not use its chip for file
  locations, but a tape as in SDLT case, and I'm not sure about LTO-2 and
  LTO-3 case).  However there is a big difference, that end-of-data ignores
  file position, whereas filemarks returns the real number of skipped
  files, so OS can track current file number just in filemarks case.

\item[OS level]
  Solaris does use just SCSI SPACE Filemarks, it does not support SCSI
  SPACE End-of-data.  When MTEOM is called, Solaris does use SCSI SPACE
  Filemarks with count = 1048576 for fast mode, and combination of SCSI
  SPACE Filemarks with count = 1 with SCSI SPACE Blocks with count = 1 for
  slow mode, so EOD mark on the tape on some older tape drives is not
  skipped.  File number is always tracked for MTEOM.

  Linux does support both SCSI SPACE Filemarks and End-of-data: When MTEOM
  is called in MT\_ST\_FAST\_MTEOM mode, SCSI SPACE End-of-data is used.
  In the other case, SCSI SPACE Filemarks with count =
  8388607 is used.
  There is no real slow mode like in Solaris - I just expect, that for
  older tape drives Filemarks may be slower than End-of-data, but not so
  much as in Solaris slow mode.  File number is tracked for MTEOM just
  without MT\_ST\_FAST\_MTEOM - when MT\_ST\_FAST\_MTEOM is used, it is not.

  FreeBSD does support both SCSI SPACE Filemarks and End-of-data, but when
  MTEOD (MTEOM) is called, SCSI SPACE End-of-data is always used.  FreeBSD
  never use SCSI SPACE Filemarks for MTEOD. File number is never tracked
  for MTEOD.

\item[Bareos level]
  When {\bf Hardware End of Medium = Yes} is used, MTEOM is called, but it
  does not mean, that hardware End-of-data must be used.  When Hardware End
  of Medium = No, if Fast Forward Space File = Yes, MTFSF with count =
  32767 is used, else Block Read with count = 1 with Forward Space File
  with count = 1 is used, which is really very slow.

\item [Hardware End of Medium = Yes|No]
  The name of this option is misleading and is the source of confusion,
  because it is not the hardware EOM, what is really switched here.

  If I use Yes, OS must not use SCSI SPACE End-of-data, because Bareos
  expects, that there is tracked file number, which is not supported by
  SCSI specification.  Instead, the OS have to use SCSI SPACE Filemarks.

  If I use No, an action depends on Fast Forward Space File.

  When I set {\bf Hardware End of Medium = no}
  and {\bf Fast Forward Space File = no}
  file positioning was very slow
  on my LTO-3 (about ten to 100 minutes), but

  with {\bf Hardware End of Medium = no} and
{\bf Fast Forward Space File = yes}, the time is ten to
100 times faster (about one to two minutes).

\end{description}

\subsection{Tape Performance Problems}
\index[general]{Tape Performance}
If you have LTO-3 or LTO-4 drives, you should be able to
fairly good transfer rates; from 60 to 150 MB/second, providing
you have fast disks; GigaBit Ethernet connections (probably 2); you are
running multiple simultaneous jobs; you have Bareos data spooling
enabled; your tape block size is set to 131072 or 262144; and
you have set {\bf Maximum File Size = 5G}.

If you are not getting good performance, consider some of the following
suggestions from the Allen Balck on the Bareos Users email list:

\begin{enumerate}
\item You are using an old HBA (i.e. SCSI-1, which only does 5 MB/s)

\item There are other, slower, devices on the SCSI bus. The HBA will
   negotiate the speed of every device down to the speed of the
   slowest.

\item There is a termination problem on the bus (either too much or
   too little termination). The HBA will drop the bus speed in an
   attempt to increase the reliability of the bus.

\item Loose or damaged cabling - this will probably make the HBA "think"
   you have a termination problem and it will react as in 3 above.
\end{enumerate}

See if /var/adm/messages (or /var/log/messages) tells you what the sync
rate of the SCSI devices/bus are. Also, the next time you reboot, the
BIOS may be able to tell you what the rate of each device is.


\subsection{Autochanger Errors}
\index[general]{Errors!Autochanger}
\index[general]{Autochanger Errors}

If you are getting errors such as:

\footnotesize
\begin{verbatim}
3992 Bad autochanger "load slot 1, drive 1": ERR=Child exited with code 1.
\end{verbatim}
\normalsize

and you are running your Storage daemon as non-root, then most likely
you are having permissions problems with the control channel. Running
as root, set permissions on /dev/sgX so that the userid and group of
your Storage daemon can access the device. You need to ensure that you
all access to the proper control device, and if you don't have any
SCSI disk drives (including SATA drives), you might want to change
the permissions on /dev/sg*.

\subsection{Syslog Errors}
\index[general]{Errors!Syslog}
\index[general]{Syslog Errors}

If you are getting errors such as:

\footnotesize
\begin{verbatim}
: kernel: st0: MTSETDRVBUFFER only allowed for root
\end{verbatim}
\normalsize

you are most likely running your Storage daemon as non-root, and
Bareos is attempting to set the correct OS buffering to correspond
to your Device resource. Most OSes allow only root to issue this
ioctl command. In general, the message can be ignored providing
you are sure that your OS parameters are properly configured as
described earlier in this manual.  If you are running your Storage daemon
as root, you should not be getting these system log messages, and if
you are, something is probably wrong.
}`

Autochanger
===========

Testing Autochanger and Adapting mtx-changer script
---------------------------------------------------

.. _sec:MtxChangerManualUsage:

.. index:: 
   triple: General; Autochanger; Testing

.. index:: 
   triple: General; Autochanger; mtx-changer

.. index:: 
   triple: General; Command; mtx-changer

.. index:: 
   triple: General; Problem; Autochanger

.. index:: 
   triple: General; Problem; mtx-changer

In case, Bareos does not work well with the Autochanger, it is
preferable to “hand-test” that the changer works. To do so, we suggest
you do the following commands:

Make sure Bareos is not running.

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 list 0 /dev/nst0 0`
.. index:: SD; mtx-changer list 

This command should print:



::

       1:
       2:
       3:
       ...



or one number per line for each slot that is occupied in your changer,
and the number should be terminated by a colon (**:**). If your changer
has barcodes, the barcode will follow the colon. If an error message is
printed, you must resolve the problem (e.g. try a different SCSI control
device name if **/dev/sg0** is incorrect). For example, on FreeBSD
systems, the autochanger SCSI control device is generally
**/dev/pass2**.

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 listall 0 /dev/nst0 0`
.. index:: SD; mtx-changer listall 

This command should print:



::

     Drive content:         D:Drive num:F:Slot loaded:Volume Name
     D:0:F:2:vol2        or D:Drive num:E
     D:1:F:42:vol42
     D:3:E

     Slot content:
     S:1:F:vol1             S:Slot num:F:Volume Name
     S:2:E               or S:Slot num:E
     S:3:F:vol4

     Import/Export tray slots:
     I:10:F:vol10           I:Slot num:F:Volume Name
     I:11:E              or I:Slot num:E
     I:12:F:vol40



:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 transfer 1 2`
.. index:: SD; mtx-changer listall 

This command should transfer a volume from source (1) to destination (2)

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 slots`
.. index:: SD; mtx-changer slots 

This command should return the number of slots in your autochanger.

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 unload 1 /dev/nst0 0`
.. index:: SD; mtx-changer unload 

If a tape is loaded from slot 1, this should cause it to be unloaded.

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 load 3 /dev/nst0 0`
.. index:: SD; mtx-changer load 

Assuming you have a tape in slot 3, it will be loaded into drive (0).

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 loaded 0 /dev/nst0 0`
.. index:: SD; mtx-changer loaded 

It should print “3” Note, we have used an “illegal” slot number 0. In
this case, it is simply ignored because the slot number is not used.
However, it must be specified because the drive parameter at the end of
the command is needed to select the correct drive.

:command:`/usr/lib/bareos/scripts/mtx-changer /dev/sg0 unload 3 /dev/nst0 0`
.. index:: SD; mtx-changer unload 

will unload the tape into slot 3.

Once all the above commands work correctly, assuming that you have the
right **Changer Command** in your configuration, Bareos should be able
to operate the changer. The only remaining area of problems will be if
your autoloader needs some time to get the tape loaded after issuing the
command. After the **mtx-changer** script returns, Bareos will
immediately rewind and read the tape. If Bareos gets rewind I/O errors
after a tape change, you will probably need to configure the
**load_sleep** paramenter in the config file
*/etc/bareos/mtx-changer.conf*. You can test whether
or not you need a **sleep** by putting the following commands into a
file and running it as a script:



::

    #!/bin/sh
    /usr/lib/bareos/scripts/mtx-changer /dev/sg0 unload 1 /dev/nst0 0
    /usr/lib/bareos/scripts/mtx-changer /dev/sg0 load 3 /dev/nst0 0
    mt -f /dev/st0 rewind
    mt -f /dev/st0 weof



If the above script runs, you probably have no timing problems. If it
does not run, start by putting a **sleep 30** or possibly a **sleep 60**
in the script just after the mtx-changer load command. If that works,
then you should configure the **load_sleep**
paramenter in the config file
*/etc/bareos/mtx-changer.conf* to the specified value
so that it will be effective when Bareos runs.

A second problem that comes up with a small number of autochangers is
that they need to have the cartridge ejected before it can be removed.
If this is the case, the **load 3** will never succeed regardless of how
long you wait. If this seems to be your problem, you can insert an eject
just after the unload so that the script looks like:



::

    #!/bin/sh
    /usr/lib/bareos/scripts/mtx-changer /dev/sg0 unload 1 /dev/nst0 0
    mt -f /dev/st0 offline
    /usr/lib/bareos/scripts/mtx-changer /dev/sg0 load 3 /dev/nst0 0
    mt -f /dev/st0 rewind
    mt -f /dev/st0 weof



If this solves your problems, set the parameter
**offline** in the config file
*/etc/bareos/mtx-changer.conf* to “1”.

Restore
=======

Restore a pruned job using a pattern
------------------------------------


.. index:: 
   triple: General; Restore; pruned job

.. index:: 
   triple: General; Problem!Restore; pruned job
.. index:: General; Regex 

It is possible to configure Bareos in a way, that job information are
still stored in the Bareos catalog, while the individual file
information are already pruned.

If all File records are pruned from the catalog for a Job, normally
Bareos can restore only all files saved. That is there is no way using
the catalog to select individual files. With this new feature, Bareos
will ask if you want to specify a Regex expression for extracting only a
part of the full backup.

::

      Building directory tree for JobId(s) 1,3 ...
      There were no files inserted into the tree, so file selection
      is not possible.Most likely your retention policy pruned the files

      Do you want to restore all the files? (yes|no): no

      Regexp matching files to restore? (empty to abort): /etc/.*
      Bootstrap records written to /tmp/regress/working/zog4-dir.restore.1.bsr

See also :ref:`FileRegex bsr option FileRegex` for more
information.

Problems Restoring Files
------------------------


.. index:: 
   triple: General; Restore!Files; Problem

.. index:: 
   triple: General; Problem; Restoring Files

.. index:: 
   triple: General; Problem!Tape; fixed mode

.. index:: 
   triple: General; Problem!Tape; variable mode

The most frequent problems users have restoring files are error messages
such as:



::

    04-Jan 00:33 z217-sd: RestoreFiles.2005-01-04_00.31.04 Error:
    block.c:868 Volume data error at 20:0! Short block of 512 bytes on
    device /dev/tape discarded.



or



::

    04-Jan 00:33 z217-sd: RestoreFiles.2005-01-04_00.31.04 Error:
    block.c:264 Volume data error at 20:0! Wanted ID: "BB02", got ".".
    Buffer discarded.



Both these kinds of messages indicate that you were probably running
your tape drive in fixed block mode rather than variable block mode.
Fixed block mode will work with any program that reads tapes
sequentially such as tar, but Bareos repositions the tape on a block
basis when restoring files because this will speed up the restore by
orders of magnitude when only a few files are being restored. There are
several ways that you can attempt to recover from this unfortunate
situation.

Try the following things, each separately, and reset your Device
resource to what it is now after each individual test:

#. Set “Block Positioning = no” in your Device resource and try the
   restore. This is a new directive and untested.

#. Set “Minimum Block Size = 512” and “Maximum Block Size = 512” and try
   the restore. If you are able to determine the block size your drive
   was previously using, you should try that size if 512 does not work.
   This is a really horrible solution, and it is not at all recommended
   to continue backing up your data without correcting this condition.
   Please see the :ref:`TapeTestingChapter` section for
   more on this.

#. Try editing the restore.bsr file at the Run xxx yes/mod/no prompt
   before starting the restore job and remove all the VolBlock
   statements. These are what causes Bareos to reposition the tape, and
   where problems occur if you have a fixed block size set for your
   drive. The VolFile commands also cause repositioning, but this will
   work regardless of the block size.

#. Use bextract to extract the files you want – it reads the Volume
   sequentially if you use the include list feature, or if you use a
   .bsr file, but remove all the VolBlock statements after the .bsr file
   is created (at the Run yes/mod/no) prompt but before you start the
   restore.

Restoring Files Can Be Slow
---------------------------


.. index:: 
   triple: General; Restore; slow

.. index:: 
   triple: General; Problem!Restore; slow

Restoring files is generally **much** slower than backing them up for
several reasons. The first is that during a backup the tape is normally
already positioned and Bareos only needs to write. On the other hand,
because restoring files is done so rarely, Bareos keeps only the start
file and block on the tape for the whole job rather than on a file by
file basis which would use quite a lot of space in the catalog.

Bareos will forward space to the correct file mark on the tape for the
Job, then forward space to the correct block, and finally sequentially
read each record until it gets to the correct one(s) for the file or
files you want to restore. Once the desired files are restored, Bareos
will stop reading the tape.

Finally, instead of just reading a file for backup, during the restore,
Bareos must create the file, and the operating system must allocate disk
space for the file as Bareos is restoring it.

For all the above reasons the restore process is generally much slower
than backing up (sometimes it takes three times as long).

Restoring When Things Go Wrong
------------------------------


.. index:: 
   triple: General; Catalog; Restore

.. index:: 
   triple: General; Restore; Catalog

.. index:: 
   triple: General; Disaster!Recovery; Catalog

.. index:: 
   triple: General; Problem; Repair Catalog

This and the following sections will try to present a few of the kinds
of problems that can come up making restoring more difficult. We will
try to provide a few ideas how to get out of these problem situations.
In addition to what is presented here, there is more specific
information on restoring a
:ref:`Client sec:BareMetalRestoreClient` and your
:ref:`Server sec:RestoreServer` in the
:ref:`RescueChapter` chapter of this manual.

Problem
    My database is broken.

Solution
    For SQLite, use the vacuum command to try to fix the database. For
    either MySQL or PostgreSQL, see the vendor’s documentation. They
    have specific tools that check and repair databases, see the
    :ref:`CatMaintenanceChapter` sections of this manual
    for links to vendor information.

    Assuming the above does not resolve the problem, you will need to
    restore or rebuild your catalog. Note, if it is a matter of some
    inconsistencies in the Bareos tables rather than a broken database,
    then running :ref:`bareos-dbcheck bareos-dbcheck`
    might help, but you will need to ensure that your database indexes
    are properly setup.

Problem
    How do I restore my catalog?

Solution with a Catalog backup
    If you have backed up your database nightly (as you should) and you
    have made a bootstrap file, you can immediately load back your
    database (or the ASCII SQL output). Make a copy of your current
    database, then re-initialize it, by running the following scripts:

    ::

           ./drop_bareos_tables
           ./make_bareos_tables

    After re-initializing the database, you should be able to run
    Bareos. If you now try to use the restore command, it will not work
    because the database will be empty. However, you can manually run a
    restore job and specify your bootstrap file. You do so by entering
    the **run** command in the console and selecting the restore job. If
    you are using the default bareos-dir.conf, this Job will be named
    **RestoreFiles**. Most likely it will prompt you with something such
    as:

    

    ::

        Run Restore job
        JobName:    RestoreFiles
        Bootstrap:  /home/user/bareos/working/restore.bsr
        Where:      /tmp/bareos-restores
        Replace:    always
        FileSet:    Full Set
        Client:     rufus-fd
        Storage:    File
        When:       2005-07-10 17:33:40
        Catalog:    MyCatalog
        Priority:   10
        OK to run? (yes/mod/no):

    

    A number of the items will be different in your case. What you want
    to do is: to use the mod option to change the Bootstrap to point to
    your saved bootstrap file; and to make sure all the other items such
    as Client, Storage, Catalog, and Where are correct. The FileSet is
    not used when you specify a bootstrap file. Once you have set all
    the correct values, run the Job and it will restore the backup of
    your database, which is most likely an ASCII dump.

    You will then need to follow the instructions for your database type
    to recreate the database from the ASCII backup file. See the
    :ref:`Catalog Maintenance CatMaintenanceChapter`
    chapter of this manual for examples of the command needed to restore
    a database from an ASCII dump (they are shown in the Compacting Your
    XXX Database sections).

    Also, please note that after you restore your database from an ASCII
    backup, you do NOT want to do a **make\_bareos\_tables** command, or
    you will probably erase your newly restored database tables.

Solution with a Job listing
    If you did save your database but did not make a bootstrap file,
    then recovering the database is more difficult. You will probably
    need to use :command:`bextract` to extract the backup
    copy. First you should locate the listing of the job report from the
    last catalog backup. It has important information that will allow
    you to quickly find your database file. For example, in the job
    report for the CatalogBackup shown below, the critical items are the
    Volume name(s), the Volume Session Id and the Volume Session Time.
    If you know those, you can easily restore your Catalog.

    

    ::

        22-Apr 10:22 HeadMan: Start Backup JobId 7510,
        Job=CatalogBackup.2005-04-22_01.10.0
        22-Apr 10:23 HeadMan: Bareos 1.37.14 (21Apr05): 22-Apr-2005 10:23:06
          JobId:                  7510
          Job:                    CatalogBackup.2005-04-22_01.10.00
          Backup Level:           Full
          Client:                 Polymatou
          FileSet:                "CatalogFile" 2003-04-10 01:24:01
          Pool:                   "Default"
          Storage:                "DLTDrive"
          Start time:             22-Apr-2005 10:21:00
          End time:               22-Apr-2005 10:23:06
          FD Files Written:       1
          SD Files Written:       1
          FD Bytes Written:       210,739,395
          SD Bytes Written:       210,739,521
          Rate:                   1672.5 KB/s
          Software Compression:   None
          Volume name(s):         DLT-22Apr05
          Volume Session Id:      11
          Volume Session Time:    1114075126
          Last Volume Bytes:      1,428,240,465
          Non-fatal FD errors:    0
          SD Errors:              0
          FD termination status:  OK
          SD termination status:  OK
          Termination:            Backup OK

    

    From the above information, you can manually create a bootstrap
    file, and then follow the instructions given above for restoring
    your database. A reconstructed bootstrap file for the above backup
    Job would look like the following:

    

    ::

        Volume="DLT-22Apr05"
        VolSessionId=11
        VolSessionTime=1114075126
        FileIndex=1-1

    

    Where we have inserted the Volume name, Volume Session Id, and
    Volume Session Time that correspond to the values in the job report.
    We’ve also used a FileIndex of one, which will always be the case
    providing that there was only one file backed up in the job.

    The disadvantage of this bootstrap file compared to what is created
    when you ask for one to be written, is that there is no File and
    Block specified, so the restore code must search all data in the
    Volume to find the requested file. A fully specified bootstrap file
    would have the File and Blocks specified as follows:

    

    ::

        Volume="DLT-22Apr05"
        VolSessionId=11
        VolSessionTime=1114075126
        VolFile=118-118
        VolBlock=0-4053
        FileIndex=1-1

    

    Once you have restored the ASCII dump of the database, you will then
    to follow the instructions for your database type to recreate the
    database from the ASCII backup file. See the
    :ref:`Catalog Maintenance CatMaintenanceChapter`
    chapter of this manual for examples of the command needed to restore
    a database from an ASCII dump (they are shown in the Compacting Your
    XXX Database sections).

    Also, please note that after you restore your database from an ASCII
    backup, you do NOT want to do a **make\_bareos\_tables** command, or
    you will probably erase your newly restored database tables.

Solution without a Job Listing
    If you do not have a job listing, then it is a bit more difficult.
    Either you use the :ref:`bscan bscan` program to scan
    the contents of your tape into a database, which can be very time
    consuming depending on the size of the tape, or you can use the
    :ref:`bls bls` program to list everything on the
    tape, and reconstruct a bootstrap file from the bls listing for the
    file or files you want following the instructions given above.

    There is a specific example of how to use **bls** below.

Problem
    Trying to restore the last known good full backup by specifying item
    3 on the restore menu then the JobId to restore, but Bareos then
    reports:

    

    ::

           1 Job 0 Files

     and restores nothing.

Solution
    Most likely the File records were pruned from the database either
    due to the File Retention period expiring or by explicitly purging
    the Job. By using the “llist jobid=nn” command, you can obtain all
    the important information about the job:

    

    ::

        llist jobid=120
                   JobId: 120
                     Job: save.2005-12-05_18.27.33
                Job.Name: save
             PurgedFiles: 0
                    Type: B
                   Level: F
            Job.ClientId: 1
             Client.Name: Rufus
               JobStatus: T
               SchedTime: 2005-12-05 18:27:32
               StartTime: 2005-12-05 18:27:35
                 EndTime: 2005-12-05 18:27:37
                JobTDate: 1133803657
            VolSessionId: 1
          VolSessionTime: 1133803624
                JobFiles: 236
               JobErrors: 0
         JobMissingFiles: 0
              Job.PoolId: 4
               Pool.Name: Full
           Job.FileSetId: 1
         FileSet.FileSet: BackupSet

    

    Then you can find the Volume(s) used by doing:

    

    ::

        sql
        select VolumeName from JobMedia,Media where JobId=1 and JobMedia.MediaId=Media.MediaId;

    

    Finally, you can create a bootstrap file as described in the
    previous problem above using this information.

    Bareos will ask you if you would like to restore all the files in
    the job, and it will collect the above information and write the
    bootstrap file for you.

Problem
    You don’t have a bootstrap file, and you don’t have the Job report
    for the backup of your database, but you did backup the database,
    and you know the Volume to which it was backed up.

Solution
    Either :command:`bscan` the tape (see below for
    bscanning), or better use :command:`bls` to find where
    it is on the tape, then use :command:`bextract` to
    restore the database. For example,

    

    ::

        ./bls -j -V DLT-22Apr05 /dev/nst0

     Might produce the following output:
    

    ::

        bls: butil.c:258 Using device: "/dev/nst0" for reading.
        21-Jul 18:34 bls: Ready to read from volume "DLT-22Apr05" on device "DLTDrive"
        (/dev/nst0).
        Volume Record: File:blk=0:0 SessId=11 SessTime=1114075126 JobId=0 DataLen=164
        ...
        Begin Job Session Record: File:blk=118:0 SessId=11 SessTime=1114075126
        JobId=7510
           Job=CatalogBackup.2005-04-22_01.10.0 Date=22-Apr-2005 10:21:00 Level=F Type=B
        End Job Session Record: File:blk=118:4053 SessId=11 SessTime=1114075126
        JobId=7510
           Date=22-Apr-2005 10:23:06 Level=F Type=B Files=1 Bytes=210,739,395 Errors=0
        Status=T
        ...
        21-Jul 18:34 bls: End of Volume at file 201 on device "DLTDrive" (/dev/nst0),
        Volume "DLT-22Apr05"
        21-Jul 18:34 bls: End of all volumes.

     Of course, there will be many more records
    printed, but we have indicated the essential lines of output. From
    the information on the Begin Job and End Job Session Records, you
    can reconstruct a bootstrap file such as the one shown above.

Problem
    How can I find where a file is stored?

Solution
    Normally, it is not necessary, you just use the **restore** command
    to restore the most recently saved version (menu option 5), or a
    version saved before a given date (menu option 8). If you know the
    JobId of the job in which it was saved, you can use menu option 3 to
    enter that JobId.

    If you would like to know the JobId where a file was saved, select
    restore menu option 2.

    You can also use the **query** command to find information such as:
    

    ::

        *query
        Available queries:
             1: List up to 20 places where a File is saved regardless of the
        directory
             2: List where the most recent copies of a file are saved
             3: List last 20 Full Backups for a Client
             4: List all backups for a Client after a specified time
             5: List all backups for a Client
             6: List Volume Attributes for a selected Volume
             7: List Volumes used by selected JobId
             8: List Volumes to Restore All Files
             9: List Pool Attributes for a selected Pool
            10: List total files/bytes by Job
            11: List total files/bytes by Volume
            12: List Files for a selected JobId
            13: List Jobs stored on a selected MediaId
            14: List Jobs stored for a given Volume name
            15: List Volumes Bareos thinks are in changer
            16: List Volumes likely to need replacement from age or errors
        Choose a query (1-16):

    

Problem
    I didn’t backup my database. What do I do now?

Solution
    This is probably the worst of all cases, and you will probably have
    to re-create your database from scratch and then bscan in all your
    volumes, which is a very long, painful, and inexact process.

    There are basically three steps to take:

    #. Ensure that your SQL server is running (MySQL or PostgreSQL) and
       that the Bareos database (normally bareos) exists. See the
       :ref:`sec:CreateDatabase` chapter of the manual.

    #. Ensure that the Bareos databases are created. This is also
       described at the above link.

    #. Start and stop the Bareos Director using the propriate
       bareos-dir.conf file so that it can create the Client and Storage
       records which are not stored on the Volumes. Without these
       records, scanning is unable to connect the Job records to the
       proper client.

    When the above is complete, you can begin bscanning your Volumes.
    Please see the :ref:`bscan` chapter for more
    details.

.. |image| image:: \idir Conf-Diagram
   :width: 80.0%
